let createReducer = (desc) => {
    let reducers = []

    for key, map of desc {
        let reducer =
            if typeof map == "function" {
                break map
            }
            else {
                break createReducer(map)
            }
        reducers.push([key, reducer])
    }

    return (state, action) => {
        let newState = {}
        for [key, reducer] in reducers {
            newState[key] = await reducer(state[key], action)
        }
        return newState
    }
}

let generateStateInfo = (source, desc) => {
    let reducers = {}
    let initialState = {}
    let mut definedActions = Set*()
    let sieves = {}
    for key, info of desc {
        let path = (source != null) ? "${source}.${key}" : key
        let initial = info.initial

        if initial == void {
            let child = generateStateInfo(path, info)
            [reducers[key], initialState[key]] = child
            definedActions = Set*([
                ...definedActions,
                ...child[2]
            ])
        }
        else {
            let actionHandlers = {}
            sieves[key] = []
            for action, func of info {
                if action.indexOf("*") != -1 {
                    let regexText = action
                        .replace(/\./g, "\\.")
                        .replace(/\$/g, "\\$")
                        .replace(/\*/g, ".*?")
                    sieves[key].push([
                        RegExp(`^${regexText}$`)
                        func
                    ])
                }
                else {
                    actionHandlers[action] = func
                    if action.startsWith("$") == true {
                        definedActions.add("${path}.${action}")
                    }
                    if action.indexOf("$") > 0 {
                        definedActions.add(action)
                    }
                }
            }
            initialState[key] = (typeof initial == "function")
                ? initial()
                : initial
            reducers[key] = (state, action) => {
                let mut actions = [action]
                if action.type == "batch" {
                    actions = action.actions
                }

                let mut newState = state
                for action in actions {
                    let mut type = action.type
                    if type.startsWith("${path}.") == true {
                        type = type[path.length + 1...]
                    }
                    let reducer = actionHandlers[type]
                    if reducer != void {
                        newState = await reducer(newState, action)
                    }
                    else {
                        for [sieve, reducer] in sieves[key] {
                            if sieve.test(action.type) == true {
                                newState = reducer(newState, action)
                                break
                            }
                        }
                    }
                }
                return newState
            }
        }
    }

    return [reducers, initialState, definedActions]
}

let createState = (desc, actionProcessors = {}) => {
    let [reducers, initialState, definedActions] = generateStateInfo(null, desc)
    let reducer = createReducer(reducers)
    let dispatch = (action) => {
        currentState = await reducer(currentState, action)
        for listener in subscriptions.values() {
            listener(currentState)
        }
        return currentState
    }
    let actions = [...definedActions].reduce(
        (actions, type) => {
            let preProcessor = actionProcessors[type] ?? (i) => i
            return {
                ...actions
                [type]: (...args) => dispatch({type, ...preProcessor(...args)})
            }
        }
        {
            $batch(...pairs) => dispatch({
                type: "batch"
                actions: pairs.map(
                    ([type, ...args]) => {
                        let preProcessor = actionProcessors[type] ?? (i) => i
                        return {type, ...preProcessor(...args)}
                    }
                )
            })
        }
    )
    let mut currentState = initialState

    let subscriptions = Map*()
    let subscribe = (listener) => {
        let key = "${Math.random()}:${Date.now()}"
        subscriptions.set(key, listener)

        return () => subscriptions.delete(key)
    }
    let validActions = [...definedActions].sort()

    return {
        get state() => currentState
        get current() => currentState
        actions
        subscribe
        get validActions() => [...validActions]
    }
}

export default createState
